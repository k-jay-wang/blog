# 阿里巴巴面试

## 面试结果

只有电话面试，后面应该木了，问的问题蛮普通的，自己还是好多没搞好，再多学习吧。

## 面试问题

### VUE的data里，什么数据是更改完之后页面DOM不会跟随更新的

我答的是对象中嵌套的对象和数组，使用push方法是不会触发更新的。  
再问：那VUE3.0里是怎么解决这个问题的？  
答：不清楚，没有看过3.0

### jQuery是怎么实现链式调用的

每次函数都返回一个this

### JS伪数组怎么转换成数组

定义：伪数组是一个含有length属性的json对象，类似nodelist，它是类似索引的方式存储数据。可以使用：  

1. Array.prototype.slice.call(obj);// slice返回一个数组，所以用他可以
2. 声明空数组，一个一个push
3. 原型继承，obj.__proto__ = Array.prototype;
4. 用ES6方法 Array.from(obj)
5. 用ES6新方法 new Set(obj)；转成set再转回Array

### 列举熟悉的设计模式

发布订阅，单例，工厂。

怎么实现单例模式？  

声明一个类，在类里面实现一个匿名类，判断实例是否已创建，如果已创建，就返回实例，否则调用匿名类构造函数，生成一个实例，把实例缓存，返回实例。

怎么实现工厂模式？

声明一个类，传入不同参数，每次调用都返回新的实例。

怎么实现发布订阅模式？

实现一个观察者，实现一个订阅者，每个订阅者都在观察者里注册回调事件，当观察者被触发时，调用各个订阅者的回调事件，触发订阅者做出反应。

### 写一个正则匹配字符串的前后空格

/(^\s*)|(\s*$)/g  
这个血妈亏，正则一定要自己背嘛。。。。

### 函数式编程里的纯函数

纯函数就是相同的输入，永远会得到相同的输出。而且没有任何可观察的副作用  
这种题丢分也太尴尬了，不知道函数式编程的痛

### CSS 使用flex=1 是什么的缩写？两个div定义了这个css，会怎么展现

flex => flex-grow flex-shrink flex-basis
两个div就是一比一的各占50%的宽度嘛

### url从输入到页面展现，中间发生了什么

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 关闭连接

下面分步解析

#### DNS解析

通过域名，向本地域名服务器查询IP地址，没有找到的话就逐级向上查询，直到查询到结果，把IP地址缓存到本地服务器，以便下次使用。  
在DNS解析阶段，有大量的查询工作，怎么优化这一点呢？就是加DNS多级缓存，DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。  
还有一点可以做就是DNS的负载均衡。DNS会根据地理位置，机器的负载量来决定返回哪台机器的IP地址。

#### TCP连接

HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。  
HTTPS是在HTTP和TCP中间加了一层SSL 或者 TLS，对HTTP报文进行加密，防止被劫持。  
三次握手，建立TCP连接。

#### HTTP请求

构建HTTP请求报文，并通过TCP协议发送到服务器指定端口。HTTP请求报文由三部分组成：请求行，请求报头和请求正文。结束后会发一个空行表示结束。

#### 服务器处理请求并返回HTTP报文

从端口接受到TCP报文开始，对TCP连接进行处理，对HTTP协议进行解析，按照报文格式进一步封装成HTTP Request对象，供上层使用，组成相应报文，返回。  
相应报文由三部分组成：状态码，响应报头和响应报文。

#### 浏览器解析返回资源，渲染页面

浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。

JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。

浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。

#### 关闭TCP连接

4次挥手，拜拜了您内。
