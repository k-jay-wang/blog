# 变量，作用域和内存问题

## 基本类型和引用类型的值

基本类型： Undefined, null, boolean string number
引用类型：Object，Array, Function 

### 动态的属性

对于引用类型，我们可以为其添加属性和方法，也可以改变和删除其属性和方法，但我们不能给基本类型的值添加属性，尽管不会报错，但也不起作用。

### 复制变量值

复制基本类型值，会在变量对象上创建一个新值，然后把值复制到新变量分配的位置上。  
复制引用类型时，只复制指针，指向的还是同一个堆区域。

### 传递参数

ECMAScript中所有函数的参数都是按值传递的，也就是说，值类型的参数就把值复制一份进去操作，引用类型的就把指针复制一份进去操作（操作的还是这个指针指向的同一块堆）。所以传对象的方式，函数内部改变了对象属性，函数外部的引用也变了就。

### 检测类型
  
typeof undefined, string, number, boolean 好使，但是null会返回object  

instanceof： 鉴定变量是否是给定引用类型的实例，那所有对象都是Object的实例，所以一直是true，但是如果用这个检测基本类型，则会返回false，因为基本类型不是对象。

Object.prototype.toString.call(obj), 这个真的操一切，基本类型和引用类型都能检测，返回[object XXXX];undefined，Null 这种的都能识别

## 执行环境和作用域

执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中。代码无法使用这个对象，但是编译器会在后台使用它。  
全局环境是最外围的环境，在浏览器中，全局环境是window对象（严格模式下不是），某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数也被销毁。全局的在关闭网页或浏览器时才销毁。  
每个函数都有自己的执行环境。执行流进入一个函数，函数的环境会被推入环境栈中，执行完毕后栈将其环境弹出，把控制权返回给之前的环境。  
当代码在环境中执行时，会创建变量对象的一个作用域链，用来保证对执行环境有权访问的所有变量和函数的有序访问。作用域链前端永远是当前所执行代码的变量对象。如果环境是函数，则将其活动对象作为变量对象。活动对象最开始只包含一个变量arguments，下一个变量来自外部环境，在下一个来自再下一个外部环境，一直延续到全局环境。全局变量对象始终是链的最后一个对象。  

### 延长作用域链

执行环境的类型统共有两种，全局和局部（函数），但还是有办法延长作用域链。具体来说，当执行流进入下列任何一个语句时，作用域链就会加长：try-catch的catch，with语句。  

### 没有块级作用域

1. 声明变量。使用var声明的变量会自动添加到最接近的环境中。如果初始化变量时没有使用var则变量被加到全局环境。
2. 查询标识符。就是函数中引用了一个变量名，必须要搜索确定变量名的定义，是一层一层向上寻找的。如果找到了就不会再向上寻找。

## 垃圾收集

### 标记清除

当变量进入环境（被定义）就将变量标记为进入环境，离开环境时，则标记为离开环境。

### 引用计数

跟踪每个变量被引用的次数，声明一个变量并将一个引用类型赋给变量时，这个值得引用次数就加1.当释放变量时，减1，然后当计数为0时，就可以回收了。  
引用计数有循环引用的问题。

### 性能问题

### 管理内存

优化内存最佳的方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，就把数据置为null来释放引用。也叫解除引用。
