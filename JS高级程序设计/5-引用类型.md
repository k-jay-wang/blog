# 引用类型

**引用类型的值（对象）是引用类型的一个实例**。在ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类（Class），但这种称呼不妥当。尽管ECMAScript技术上是面向对象语言，但它不具备传统面向对象语言所支持的类和接口等基本结构。

新对象是使用new操作符后面加一个构造函数来创建的。构造函数本身是一个函数，只是函数是出于创建新对象的目的而定义的。，请看：

```js
var person = new Object();
```

这行代码创建了Object引用类型的一个实例，然后把该实例保存在变量person里。使用的构造函数时Object();它只为新对象定义了默认的属性和方法。ECMAScript提供了很多原生引用类型。

## Object类型

到目前为止，我们看到的大多数引用类型值都是Object类型的实例。

创建object实例的方式有两种：

* 使用new操作符后跟Object构造函数 var person = new Object(); person.name = 'sb';
* 使用对象字面量表示法, 是一种简写形势 var person = {name: 'sb'};

ECMAScript表达式上下文指的是能够返回一个值。最后一个属性定义的后面不加逗号，因为会在IE7等浏览器中报错。使用对象字面量法创建引用类型值时，属性名也可以使用字符串。  
在调用对象字面量定义对象时，实际上不会调用Object构造函数  
访问对象的属性可以通过点表示法或者方括号语法。方括号主要优点是可以使用变量来访问属性。  
牛逼的来了，person["first name"]是可以存在这样的带空格属性的，但是点语法访问不了，括号语法就行

## Array类型

数组，**数据的有序列表**，但与其他语言的数组不同，**ECMAScript数组的每一项可以保存任何类型的数据。**而且**ECMAScript的数组大小是可以动态调整的**，即可以随着数据的添加而自动增长以容纳新增数据。  
创建数组的基本方式有两种

* var colors = new Aarray(); 
  * 如果预先知道数组长度，也可以传递进去。var colors = new Array(20);
  * 也可以传递数组要包含的数据项 var colors = new Array('red', 'green')
  * 也可以省略new操作符 var colors = Array(5);
* 使用数组字面量表示法 var colors = ['red', 'blue', 'green'], 在数组字面量最后一位后面也加逗号的话，会引起BUG，在不同浏览器下数组长度不同，有的会加一个undefined（IE），有的只会有前几个元素。**与对象一样，调用数组字面量创建数组时也不会调用Array的构造函数**

读取或设置数组值时，要使用方括号并提供基于0的数字索引。查询的时候如果数字索引小于数组长度，则返回当前索引的数据，如果大于数组长度，返回undefined。如果是设置数组，索引小于数组长度，则修改数组，索引大于数组长度，则数组长度自动增长至索引+1，然后增加值，中间的全用undefined补齐。  
数组的长度保存在其length属性中，这个属性值始终会返回0或更大的值。**length不是只读的**，所以通过设置这个属性，可以从数组的末尾移除项或向数组中增加新项。  
也可以用这种沙雕方式在数组末尾添加新项，如person[person.length] = 'sb';

### 检测数组

使用 if (person instanceof Array) {}来判断是不是数组。但是这种方式的问题在于，如果一个网页包含多个框架（不太懂？），那实际上就会有多个不同版本的Array构造函数，如果从一个框架传入一个数组。那么传入的数组在第二个框架中就不能判断出来了。  
为解决instanceof的问题, ECMAScript5新增了Array.isArray()方法。

### 转换方法

如前所述，所有对象都有toLocaleString(), toString(). valueOf()方法。其中，调用数组的toString()方法会返回由数组中的每个值的字符串形势拼接而成的一个以逗号分隔的字符串。而调用valueOf返回的还是数组。实际上，为了创建这个字符串会调用数组中每一项的toString方法。

数组继承的toLocalString，toString，valueOf方法。在默认情况下都会以逗号分隔的字符串形式返回数组项。如果使用join方法，则可以使用不同的分隔符来创建字符串。join不传值或者传undefined，会按照逗号做分隔，IE低版本会使用undefined做分割😹

### 栈方法

ECMAScript数组也提供了一种让数组类似其他数据结构的方法。栈是LIFO（后进先出）的数据结构，数组专门提供了push 和 pop方法，来实现栈功能。

```js
var colors = new Array();
var count = colors.push('red', 'green');
alert(count);   // 2
count = colors.push('black');
alert(count)    // 3
var item = colors.pop();
alert(item);    // black
alert(colors.length)    // 2
```

由此可知，push是在数组最后一位增加值，pop是取走最后一位的数据，哪怕你最后操作的项是其他位置，pop也只取走最后一位的数据

### 队列方法

队列数据的访问规则是FIFO（先进先出）。也就是队列在数组末尾添加项，在数组头移除项。  
调用的模拟方法是push()最后一位插值，shift()返回第一位删除值。  
还有unshift()方法，用于向数组前端增加任意个项，并返回数组的新长度。也可以用unshift() 和 pop() 实现反向队列。  
IE7下unshift总会返回undefined而不会返回长度

### 重排序方法

数组中已经有两个可以用来重排序的方法：reverse和sort，reverse会反转数据项的顺序。  
但是reverse不太灵活，所以有了sort  
默认sort方法按升序排列数组项(从小到大)，为了实现排序，sort会调用每个数组项的toString方法，然后比较得到的字符串确定如何排序。即使数组里每项都是数值，sort也会调用toString。  
所以就使得sort不太好，所以sort函数接受比较函数作为参数，比较函数接收两个参数，如果第一个参数应该位于第二个参数之前就返回一个负数。如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。

### 操作方法

concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组的一个副本。然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给concat的是一或多个数组，则该方法会将这些数组中的每一项都添加到结果数组中。如果传递的是值不是数组，这些值就会简单的添加到结果数组的末尾。**原数组保持不变**

slice()方法能够基于当前数组中的一个或多个项创建一个新数组，slice方法可以接受一个或两个参数，就是要返回项的起始和结束项。在只有一个参数时，slice返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项，**但不包括结束位置的项**，**slice方法不会影响原始数组**

splice()方法：主要用途是向数组中部插入项。3种用法

* 删除：可以删除任意数量的项。只需指定2个参数：要删除的第一项的位置和要删除的项数。例如：splice(0,2)会删除数组中的前2项。
* 插入：可以向指定位置插入任意数量的项。只需提供3个参数：起始位置，0，要插入的项。如果要插入多个项，可以再插入第四，第五，以至任意多个项。
* 替换：向指定位置插入任意多个项。同时删除任意数量的项，只需指定3个数。起始位置，要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

splice方法始终会返回一个数组，该数组中包含从原始数组中删除的项，如果没删除，就返回一个空数组。

### 位置方法

ECMAScript5为数组添加了两个位置方法。indexOf()和lastIndexOf()。这两个方法都接收两个参数。要查找的项和表示查找起点位置的索引。indexOf从头往后查找，lastIndexOf是从末尾往前查找。两个方法都要返回查找的项在数组中的位置，没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符。

### 迭代方法

ECMAScript5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响this值。传入的这些方法中的函数都会接收3个参数：数组项的值，该项在数组中的位置和数组对象本身。根据方法不同，函数执行后的返回值可能会也可能不会影响所访问的返回值，这是5个迭代方法：

* every() 对数组每一项运行给定函数，如果函数对每一项都返回true，则返回true。
* filter() 对数组每一项运行给定函数，返回该函数会返回true的项组成的数组。
* forEach() 对数组每一项运行给定函数，无返回值
* map() 对数组每一项运行给定函数，返回每次调用的结果组成的数组。
* some() 对数组每一项运行给定函数，如果该函数对任一项返回true，则返回true。

以上方法都不会修改数组中包含的值

### 缩小方法

新增两个缩小数组的方法reduce和reduceRight，这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce方法从数组的第一项开始，逐个遍历到最后，而reduceRight则从数组最后一项开始，向前遍历到第一项。  
这两个方法都接收两个参数：一个在每一个项上调用的函数和作为缩小基础的初始值。传入函数接收四个参数：前一个值，当前值，项的索引和当前数组对象。此函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上。

## Date类型

ES的Date类型是在Java的Date类基础上构建的，为此Date类型使用UTC 1970年1月1日0点开始经过的毫秒数来保存日期。在这种数据存储格式的条件下，Date可以精确到1970年1月1日到之后的285616年。

调用new Date()创建一个日期对象，当不传递参数时，新创建的对象自动获得当前的日期和时间。如果想根据特定的日期和时间创建日期对象，必须穿入该日期的毫秒数。为简化这一过程。Date提供两个方法：Date.parse()和Date.UTC()。  
其中parse方法接收一个表示日期的字符串参数。然后尝试根据这个字符串返回相应日期的毫秒数。没有规定字符串格式，所以通常是因地区而异。如果字符串不能表示日期，那么它会返回NaN。实际上，如果直接传了个字符串，Date内部也会调用一次parse方法  
Date。UTC() 也同样返回表示日期的毫秒数，它的参数分别是年，以0起头的月，日，时，分，秒，毫秒。年和月都是必填项。和parse一样。Date()函数也会模仿UTC函数，但是Date()的日期和时间都是基于本地时区而非GMT。  
Date.now() 返回当前时间的毫秒数。不支持此函数的也可以用+new Date();日期转成数值型会返回毫秒值。

### 继承的方法

Date类型也重写了toLocalString(), toString(), valueOf()的方法。

* toLocaleString() 按照浏览器设定的地区相适应的格式返回日期和时间
* toString() 返回带有时区信息的日期和时间。
* valueOf() 返回日期的毫秒值。

### 日期格式化方法

* toDateString() 以特定于实现的格式显示星期几，月，日和年
* toTimeStrng() 以特定于实现的格式显示时分秒和时区
* toLocaleDateString() 以特定于地区的格式显示星期几，月，日和年
* toLocaleTimeString() 以特定于实现的格式显示时分秒
* toUTCString() 以特定于实现的格式显示完整的UTC日期

### 日期，时间组件方法

妈的有好多，不写了

## RegExp类型

ECMAScript通过RegExp实现正则。  
var expression = /pattern/flags;

其中的模式pattern部分可以是任何简单或复杂的正则表达式。可以包含字符类，限定符，分组，向前查找及反向引用。每个正则都可以带一个或多个标志（flags）。有3个标志

* g 全局
* i 不区分大小写
* m 多行模式

除了通过上面的字面量形式创建，还可以调用构造函数。var pattern = new RegExp('pattern', 'flags');

### RegExp 实例属性

regexp的每个实例都有以下属性，通过这些属性可以取得有关模式的各种信息。

* global 是否设置了g
* ignoreCase 是否设置了i
* lastIndex 表示开始搜索下一个匹配项的字符位置。从0算起
* multiline 是否设置了m
* source 正则表达式的字符串表示，按照字面量形式返回。

### RegExp实例方法

主要方法exec(), 专门为捕获组而设计的。exec接受一个参数。既要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项时返回null。返回的数组虽然是Array的实例，但包含两个额外的属性：index和input。其中，index表示匹配项在字符串中的位置。而input表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。

![正则表达式捕获](./assets/regexpdemo1.png)

对于exec方法而言，加g，也只会每次返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用exec将始终返回第一个匹配的。加上g之后呢每次都会继续往下查找匹配项。

第二个方法是test，接收一个字符串参数。在模式与参数匹配的情况下返回true，否则返回false。  
regexp实例继承的tolocalestring和toString方法都会返回正则的字面量。

### RegExp构造函数属性

* input     最近一次要匹配的字符串
* lastMatch 最近一次的匹配项
* lastParen 最近一次的捕获项
* leftContent input字符串中lastMatch之前的文本
* multiline 是否所有表达式都使用多行模式
* rightContent  input字符串中lastMatch之后的文本

### 模式的局限性

正则表达式还有一些不支持的特性

## Function 类型

函数实际上是对象哈哈哈。

每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上是一个指向函数的指针。不会与某个函数绑定。可以通过三种方式定义函数

```js
function sb() {}
var sb = function() {}
var sb = new Function("", "", "")// 最后一个参数被视为函数体
```

函数是对象，函数名是指针，所以可以多个函数名对应一个函数

### 没有重载

原因很清楚，是因为函数名是指针，声明两个一样名字的函数，本质上是对函数名进行了两次赋值。

### 函数声明与函数表达式

解析器在向执行环境中加载数据时，对函数声明和函数表达式不是一起加载，而是先读取函数声明，使其在执行任何代码前可用（可访问）。至于函数表达式，必须等到解析器执行到它所在的代码行，才会真正被解释执行。  
也就是函数声明会被优先解析执行，提升到顶部。只在函数声明里能用。  
当使用变量var a = function() {}的形式时不会提升到顶部，运行会报错（实测不会报错，估计是因为变量提升的问题）

### 作为值得函数

因为ECMAScript中的函数名本身就是变量。所以函数也可以作为值来使用。也就是说：不只可以像传递参数一样把函数传递给另一个函数。而且可以将一个函数作为另一个函数的结果返回。

```js
function callsomefunction(somefunction, args) {
    return somefunction(args)
}
```

要访问函数指针而不执行函数的话，把后面的圆括号去掉就行

### 函数值内部属性

在函数内部有两个特殊的对象，arguments和this。arguments就是传入参数的类数组对象。这个对象还有一个callee属性，此属性是一个指针，指向拥有这个arguments的函数。  
callee基本用途就是给迭代解耦。严格模式下调用callee会报错。  
另一个特殊属性是this，this引用的是函数据以执行的环境对象——也可以说是this的值（当在网页全局环境调用函数时，this对象指向的是window，严格模式下是undefined）  
还有一个caller，这个属性中保存着调用当前函数的函数的引用，如果是全局环境调用当前函数，caller是null。严格模式下不能为caller赋值，否则会报错。

### 函数属性和方法

既然函数是对象，那么函数也会有自己的属性和方法。每个函数都包含两个属性。length和prototype。  
length属性表示函数希望接受的命名参数的个数。

对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString() valueOf(), toLocaleString()等方法其实都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype的属性是非常重要的。在ES5中prototype属性不可枚举，所以for-in不可见。

每个函数都有两个非继承而来的方法，call和apply。用途是在特定作用域中调用函数，实际上等于设置函数体内this对象的值。  
call接受的参数，第一个是在其中运行函数的作用域，剩下的是参数  
apply接受俩参数，第一个是在其中运行函数的作用域，第二个是数组实例或者arguments对象

使用call和apply最大的好处就是对象不需要与函数有耦合。

bind方法，这个方法会创建一个函数的实例，实例的this值被绑定到传给bind函数的值。  
var myshow = showColor.bind(obj);  
myshow();  
**每个函数继承的toString和toLocaleString()，valueOf都会返回函数的代码。**

## 基本包装类型

3个，Boolean, String, Number  
每当读取一个基本类型时，会创建一个对应的基本类型包装对象。从而给基本类型赋予一些方法。  
var str = "adsdsa"; str.susstring(0, 2);  
当访问str时，其实是读取模式，在读取模式中访问字符串时，会自动完成一下处理：

1. 创建String()类型的实例
2. 在实例上调用指定的方法
3. 销毁这个实例

引用类型和包装对象类型的区别就在于对象的生存期，使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前一直都保存在内存中。而自动创建的包装对象，只存在执行的这一瞬间，执行完就销毁了。这也就意味着我们不能为包装对象添加属性和方法。

当然也可以显示的调用String,Boolean,Number来创建基本包装类型的对象。不过最好别做，因为你很容易不知道自己在处理的到底是值类型还是引用类型。对这样的包装对象调用typeof会返回object。当使用new标签的时候调用的就是构造函数，返回的是对象，不用new标签，调用的就是转型函数，返回的是基本类型值。  

**所有包装类型的对象都会被转成布尔值true**

### boolean类型

Boolean重写了valueOf方法，返回布尔值true或false，重写了toString方法，返回字符串的“true” "false"  
Boolean对象的生成 var a = new Boolean(true);  
Boolean值得生成 var b = false;  
两个的区别，a会被转成true，因为它是一个对象，b就是布尔值false。a instanceof  Boolean是true，因为它是Boolean类型的实例，而b不是，所以b instanceof Boolean 是false；  
永远不要使用new Boolean就完事了

### Number类型

Number类型重写了valueOf，toString，tolocalestring方法。valueOf返回Number的值类型的值，另外两个返回字符串形式的值。toString还可传参数，指示基数，还记得吗？基数在2到36之间。  
除此之外Number还实现了一些用于将数值格式化的方法。  
toFixed方法，按照指定的小数位返回数值的字符串表示。如果小数位超过规定的位数，会自动做四舍五入。  
toExponential() 返回以指数计数法表示的数值的字符串形式，接受一个参数用于指定结果中的小数位数。  
tpPrecision方法，接受一个参数指定结果中的所有数字的位数。会自动挑选指数和小数哪个更合适就用那个。  
最后，还是不要实例化Number类型，因为返回的还是对象。

### String类型

String对象的方法也可以在所有基本的字符串值中访问。其中的valueOf，toString和toLocaleString方法都返回对象所表示的基本字符串值。  
String类型的每个实例都有一个length属性，表示该字符串有多少个字符，还记得吗，length不准确，因为有的是多字节字符，比如一些Unicode编码值。会算做一个。length只读，不可修改。

字符方法：用于访问字符串中特定字符的方法charAt() 和 charCodeAt(),这两个方法都接收一个参数，即基于0的字符位置。其中charAt方法以单字符字符串的形式返回给定位置的那个字符。charCodeAt返回的是这个字符的字符编码。  
在支持浏览器中还可以通过方括号方式获取特定字符。  

字符串操作方法：

concat：用于将一个或多个字符串拼接起来。返回拼接得到的字符串。  
slice,substr和substring这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一到两个参数。第一个参数指定子字符串的开始位置。第二个参数指定子字符串到哪里结束。具体来说，slice和substring的第二个参数指得是子字符串最后一个字符后面的位置。而substr的第二个参数指的是返回的字符个数。如果这些方法没接收到第二个参数，则将字符串的长度作为结束位置。这三个也不会修改原来的字符串，只会返回一个新的字符串。  
在传入负值的情况下，slice会把负值与字符串长度相加，substr会把第一个参数的负数加上字符串长度，第二个参数转为0。substring方法会把所有负数转为0.而且substring的方法按照传给他的两个参数大小判断哪个是开始哪个是结尾。

字符串位置方法：

两个可以查询子字符串的方法 indexOf和lastIndexOf，这两个方法都是从一个字符串中搜索给定的字符串，然后返回子字符串的位置。没找到的返回-1.两个的区别是一个从前往后搜，一个从后往前搜，然后这两个方法接受第二个参数，指定搜索的起始值。  
trim方法，去除左右两侧空格。

字符串大小写转换方法：

toLowerCase,toUpperCase,toLocaleLowerCase,toLocaleUpperCase;

字符串模式匹配法

match：字符串的这个方法类似正则的exec，接受一个参数，要么是正则，要么是正则对象。  
string.match(regexp)  
match方法返回一个数组。数组第一项是与模式匹配的字符串，剩下的每一项是被捕获的字符串。  
search：也是接收一个正则，但是是从前往后查找，返回第一个匹配项的索引。如果没有匹配项，则返回-1。  
replace：为简化替换字符串操作而生的。接收两个参数，第一个参数是regexp或者字符串。第二个参数是字符串或函数。如果第一个参数是字符串，则只会替换第一个子字符串。想替换所有字符串就必须使用正则加g，  
第二个参数为函数时，在只有一个匹配项的情况下，会向函数传递3个参数，模式的匹配项，匹配项在字符串中的位置，还有原始字符串。在捕获多个匹配项的情况下，传递的参数时模式的匹配项，第一个捕获的匹配项，第二个捕获的匹配项。。。但最后两个参数依然是匹配项的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项。  
split：将字符串根据给出的分隔符把字符串分割成多个子字符串，将结果放到一个数组中。还接受第二个参数，用于指定数组长度，超过的就不往数组里存了。

localecompare方法： 比较两个字符串，并返回，比较两个字符串在字符串编码表里的位置，参数在本体前返回1，在本体后返回-1，等于本体返回0 本体.localeCompare(参数)；

fromCahrCode方法：接受1或多个字符串编码，转成字符串。

HTML方法：略

## 单体内置对象

由ECMAScript实现的不依赖于宿主环境的对象。例如之前讲的Object,Array,String,Function等等。现在介绍两个Global,Math.

### Global对象

global对象是不存在的，大概意思是global对象是兜底儿对象，不属于其他任何对象的属性和方法，最终都是global的属性和方法。事实上，没有全局对象或全局函数，所有在全局作用域中定义的属性和方法，都是global对象的属性和方法。之前我们介绍过的哪些parseInt，isNaN都是global的属性和方法。除此之外，还包含一些其他的方法。

#### URI编码方法

encodeURI和encodeURIComponent方法可以对URI（通用资源标识符）进行编码，以便发送给浏览器。有效的URI不能包含某些字符，比如空格。那么这两个方法就能对URI进行编码，用特殊UTF-8编码代替无效字符。从而让浏览器能理解。  
其中，encodeURI主要用于整个URI，而encodeURIComponent主要用于对URI中某一段进行编码。区别在于，encodeURI不会对本身属于URI的特殊字符进行编码如:/?#，而encodeURIComponent会对所有非标准字符进行编码。对应的有decodeURI，decodeURIComponent。只能对应的使用哦

#### eval方法

eval就像是一个完整的JavaScript解析器。只接受一个参数，就是要执行的JavaScript字符串。然后把执行结果插入原位置。通过eval执行的代码被认为是包含该次调用的执行环境的一部分。因此被执行的代码和该执行环境有相同作用域。  
在eval中创建的任何变量或函数都不会提升。严格模式下外部访问不到eval中创建的任何变量或函数。为eval赋值也会导致错误。

#### global对象的属性

undefined，null，nan， Infinity都是global的属性，还有Object，Function，Array，Boolean，String， Number，Date，RegExp，Error，等等

#### window对象

ECMAScript没有指出如何访问global对象， 但是浏览器中都是将global对象作为window的一部分实现的。因此这些global的属性都成为了window的属性。

### Math对象

#### math对象的属性

不讲  
min()和max(),用来求一组数中最大和最小值的方法。  
四舍五入方法：

* Math.ceil() 向上进一位，25.9 变成26，25.1变成26
* Math.floor() 抹去小数
* Math.round() 四舍五入

random():返回一个0-1之间的随机值。不包含0和1.  
还有一些sin,cos,asin,acos,tan,atan,abs,这样的

## 总结

对象在JavaScript中被称为引用类型的值。而且有一些内置的引用类型可以用来创建特定对象。

* 引用类型与面向对象中的类相似，但实现不同
* Object是一个基础类型，其他所有类型都从Object继承了基本的行为
* Array类型是一组值的有序列表。
* 函数实际上是Function类型的实例，所以函数也是对象。。
