# 面向对象的程序设计

面向对象的语言有一个标志，就是它们都有类的概念。而通过类可以创建任意多个具有相同属性和方法的对象。  
ES中对象的定义：无序属性的集合，其属性可以包含基本值，对象或者函数。所以我们可以把对象想成散列表。每个对象都是基于一个引用类型创建的。这个引用类型可以是原生类型，也可以使自定义的类型。

## 理解对象

var person = new Object();  
person.name = "sb"  
熟悉嘛？构造函数式声明对象。只不过我们常用对象字面量方法声明对象。区别是？对象字面量方法声明时不会执行Object构造函数。  

### 属性类型

ECMAScript中有两种属性类型：数据属性和访问器属性。

#### 1. 数据属性

数据属性包含一个数据值的位置。在这个位置可以读取和写入值，数据属性有4个描述其行为的特性：

* [[Configurable]] 表示能否通过delete删除属性从而重新定义属性。能否修改属性的特性，或者能否把属性修改为访问器属性。像直接定义的属性，它们的此特性默认为true。
* [[Enumerable]]表示能否通过for-in循环返回属性，默认值为true
* [[Writable]]表示能否修改属性的值默认为true
* [[Value]]包含这个属性的数据值。读取属性值时，从这个位置读，写入属性值时，把新值保存在这个位置，默认是undefined

要修改属性默认的特性，必须使用ECMAScript5的Object.defineProperty()方法。这个方法接收三个参数，属性所在对象，属性的名字和一个描述符对象。其中，描述符对象的属性必须是：configurable，enumerable，writable，value，设置其中的一个或多个值，可以修改对应的特性值。例如：

```js
var person = {};
Object.defineProperty(person, "name", {
    writable: false,
    value: 'sb',
    enumerable: false
})
alert(person.name)  // sb
person.name = 'nb';
alert(person.name)  // sb
```

如上，设置一个只读属性name，如果尝试修改name，非严格模式下不生效，严格模式下报错。**注意，configurable属性一旦定义为false，就不能再改回true了，而且一旦改成了false，除了修改writable属性，其他的属性也都不可修改了**  
在调用defineProperty时，如果不指定configurable，enumerable和writable，那他们默认都是false。

#### 2. 访问器属性

访问器属性不包含数据值。他们包含一对儿getter和setter函数（不过这俩函数都不是必须的）。在读取访问去属性时，会调用getter函数。这个函数负责返回有效的值。在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下四个特性：

* [[Configurable]] 表示能否通过delete删除属性从而重新定义属性。能否修改属性的特性，或者能否把属性修改为数据属性。像直接定义的属性，它们的此特性默认为true。
* [[Enumerable]] 表示能否通过for-in循环返回属性。对于直接在对象上定义的属性，它默认是true
* [[Get]] 在读取属性时调用的函数。默认undefined
* [[Set]] 在写入属性时调用的函数，默认undefined

访问器属性不能直接定义，必须使用Object.defineProperty()来定义，还是一样，看demo：

```js
var book = {_year: 2004, edition: 1};
Object.defineProperty(book, "year", {
    get: function() {
        return this._year;
    },
    set: function(newVal) {
        if (newVal > 2004) {
            this._year = newVal;
            this.edition += 1;
        }
    }
})
book.year = 2005;
alert(book.edition) // 2
```

上面的代码创建了一个book对象，给它定义了两个默认属性，_year和edition，_下划线是一种常用记号，表示只能通过对象方法访问的属性。而访问器属性year则包含一个getter和一个setter函数。getter返回_year的值，setter设置_year的值和修改edition的值。  
也不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，只指定setter的属性也不可读，尝试反着来的操作在非严格模式下不起作用（返回undefined），严格模式下会报错。

### 定义多个属性

使用Object.defineProperties(obj, args);此函数接受两个参数，一个是要加属性的对象，第二个是对象形式的属性对象

```js
var book = {};
Object.defineProperties(book, {
    _year: {
        writable: true,
        value: 1
    },
    year: {
        get: function() {},
        set: function() {}
    }
})
```

### 读取属性的特性

使用Object.getOwnPropertyDescriptor()方法，接收两个参数，属性所在的对象和要读取其描述符的属性名。返回一个对象，里面包含属性的特性为key，特性值为value。

## 创建对象

虽然使用Object构造函数和对象字面量都可以创建单个对象，但这些方式有个缺点：代码重复。为解决这个问题，开始使用工厂模式的一个变体。

### 工厂模式

工厂模式抽象了创建具体对象的过程。考虑到在JavaScript中无法创建类，开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。如下代码：

```js
function createPerson(name, age, job) {
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {alert(this.name)};
    return o;
}
var p1 = createPerson("sb", 18, "aa");
var p2 = createPerson("s2b", 18, "bb")
```

工厂模式通过一个函数简单粗暴的解决了创造多个相似对象的问题。但是无法解决对象识别的问题。即怎样知道一个对象的类型，然后就用到新的模式

### 构造函数模式

构造函数可用来创建特定类型的对象。如Function，Array,Object 这样的原生构造函数，在运行时自动出现在执行环境中，除此之外也可以创建自定义构造函数，从而定义自定义对象类型的属性和方法。也就是使用构造函数模式。

```js
function Person(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        alert(this.name)
    };
}

var p1 = new Person("sb", 18, "dd")
var p2 = new Person("sb2", 19, 'bb')
```

我们发现这样写和工厂模式有一些不同，它没有显示的创建对象，没有赋值给对象，而是赋值给this。没有return。

要创建一个Person的新实例，必须使用new操作符，会经历一下四个步骤：

* 创建一个新对象
* 将构造函数的作用域赋给新对象（this就指向了这个新对象）
* 执行构造函数中的代码（为新对象添加属性）
* 返回新对象

在例子的最后，p1和p2分别保存着Person的一个不同的实例，这两个对象都有一个constructor（构造器）属性。这个属性指向Person。  
对象的constructor属性最初是用来标识对象类型的。但是提到检测对象类型，还是instanceof要可靠一些。我们在这个例子中创建的对象既是Object的实例，又是Person的实例。  
创建自定义构造函数意味着将来可以将它的实例标识为一种特殊的类型。这就是构造函数模式比工厂模式强的地方。

#### 将构造函数当做函数

构造函数与其他函数的不同在于调用它们的方式不同。不过构造函数也不存在特殊语法，任何函数，只要通过new来调用，那它就可以作为构造函数。而任何函数如果不通过new调用，那它跟普通函数也没啥区别。例子：

```js
// 使用new当构造函数调用
var person = new Person("sb", 18, "dd")
person.sayName();   // sb
// 当普通函数使用
Person('2b', 12, 'bb')
window.sayName();   //  2b
// 在另一个对象作用域里使用
var o = {};
Person.call(o, '3b', 15, 'cc')
o.sayName() // 3b
```

#### 构造函数的问题

主要问题就是每个方法都要在每个实例上重新创建一遍，那我们想创建一个通用的方法，不用每次都创建函数对象，就可以这么做，把函数定义放到构造函数外面，在里面绑定时只绑定指针。但是这样又有问题，全局环境下的函数太多了。而且耦合度很高。，这种问题就使用原型模式解决。

### 原型模式

我们创建的每一个函数都有prototype(原型)属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype属性就是通过调用构造函数而创建的那个对象实例的原型对象。也就是：

```js
var B = new function() {
    this.a = '12';
    this.sayA = function() {alert(this.a)};
}
var b = new B();
b.__proto__ == B.prototype  // true
```

使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。也就是说不必在构造函数中定义公用方法，可以把方法放到原型对象中，这样就能所有对象实例共享了。那属性放到原型上，就也是共享的，所以要注意一个修改，别的引用都会变。

#### 理解原型对象

只要创建了一个新函数，就会根据一种特定的规则为该函数创建一个prototype属性，这个属性指向函数的原型对象。在默认情况下，所有原型对象都会自动获得一个constructor属性，这个属性包含一个指向prototype属性所在函数的指针。而通过这个构造函数，我们还可以继续为原型对象添加其他属性和方法。  
创建了自定义的构造函数后，它的prototype默认只会取得constructor属性。至于其他方法，则都是从Object继承而来的。当调用构造函数创建一个新实例后，该实例的内部包含一个指针，指向构造函数的prototype。浏览器中这个指针叫__prpto__ 。要明确的是，这个指针连接存在于实例和构造函数原型对象之间，而不是存在于实例和构造函数之间。  
可以通过isPropertyOf（）方法来确定对象之间是否存在这种关系。  
ES5新增了一个Object.getPropertyOf()可以返回对象的__proto__的值。  

每当代码读取某个对象的某个属性的时候，都会执行一次搜索。搜先从对象自身开始，找不到的话继续搜索指针指向的原型对象。这就是多个对象实例共享原型保存的属性和方法的基本原理。

虽然可以通过对象实例访问原型上的属性和方法， 但是却不能通过对象实例重写原型中的值。我们可以通过在实例中添加这个同名属性的方式来屏蔽原型的属性。

使用hasOwnProperty()可以检测一个属性是来自对象实例自身还是来自原型。

#### 原型与in操作符

两种方式使用in操作符，单独使用和在for-in循环中使用。单独使用时，in操作符会在通过对象能够访问给定属性时返回true。无论属性在实例中还是在原型中。  
当使用for-in循环时，返回的是所有能通过对象访问的，可枚举的属性，其中既包括对象属性，也包括原型属性，屏蔽了原型中不可枚举属性的实例属性也会在for-in里返回。  
要取得对象上的所有可枚举实例属性，可以使用Object.keys()方法。  
如果要得到所有实例属性，不论是否可枚举，就可以用Object.getOwnPropertyNames()

#### 更简单的原型语法

就是使用 Class.prototypr = {...}; 这样有一个坏处，就是原型的构造函数不再指向Class了，而是指向新对象的构造函数，也就是Object构造函数。如果constructor很重要，那么在prototype对象里再设置一下就行。把constructor指回当前构造函数指针。但是这样带来的第二个问题就是constructor变成可枚举可修改的属性了，这时再用defineProperty设置一下不可枚举补课修改就行了。

#### 原型的动态性

由于在原型上查找值是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来。哪怕是后修改原型对象。  
当然，如果你实例创建完之后把类的原型对象给重新赋值了，那么实例就找不到原型对象了，原因就是实例的__proto__是保存的指向构造函数最初prototype的指针，那么构造函数的原型指针被重新修改，就切断了构造函数与最初原型之间的联系。记住：**实例中的指针只指向原型，而不指向构造函数。**

#### 原生对象的原型

原生对象也有原型prototype，可以在原生对象类型的构造函数的原型上添加通用方法。

#### 原型对象的问题

原型模式省略了为构造函数传递初始化参数的环节，结果是所有实例在默认情况下都将取得相同的属性值。原型模式最大的问题是它共享的本性。  
原型中所有属性都是被所有它的实例所共享。当然值类型无所谓，实例也无法修改原型上的值类型，但是引用类型就有问题了，实例会修改原型上的引用类型的值。

### 组合式使用构造函数模式和原型模式

呐，这个就是自定义类型的最常见方式，组合使用构造函数模式和原型模式。
